import { randomBytes } from 'crypto';
import { Response } from 'express';
import * as OTPAuth from 'otpauth';
import * as QRCOde from 'qrcode';
import { PassThrough } from 'stream';
import { encode } from 'hi-base32';
import { hash, compare } from 'bcrypt';
import UserService from "../user/user.service";
import { Unauthorized, Forbidden, NotFound } from '@/utils/exceptions/clientErrorResponse';

class AuthService {
  public UserService = new UserService();
  
  /**
   * generateRandomBase32
   */
  public generateRandomBase32() {
    const buffer = randomBytes(15);
    const base32 = encode(buffer).replace(/=/g, "").substring(0, 24);
    return base32;
  }

  /**
   * generateTOTP
   */
  public generateTOTP(secret: string, label?: string) {
    //TODO generateTOTP(secret, options?), options?:{ label: user.email, }
    let newTOTP = new OTPAuth.TOTP({
      issuer: process.env.APP_NAME,
      label: label || process.env.APP_LABEL,
      algorithm: 'SHA1',
      digits: 6,
      period: 30,
      secret: secret
    });
    return newTOTP;
  }

  /**
   * generateOTP
  */
  public async generateOTP(userId: string) {
    const user = await this.UserService.findById(userId);

    const base32_secret = this.generateRandomBase32();

    // new time-based otp
    let totp = this.generateTOTP(base32_secret, user.email);

    let otp_url = totp.toString();

    // update user otp_auth_url and otp_base32
    user.otp_auth_url = otp_url;
    user.otp_base32 = base32_secret;
    await user.save();

    return { otp_url, base32_secret };
  }

  /**
   * verifyOTP
   */
  public async verifyOTP(userId: string, token: string) {
    const user = await this.UserService.findById(userId);
    const secret = user.otp_base32;

    let totp = this.generateTOTP(secret, user.email);

    let delta = totp.validate({ token });

    if(delta === null) {
      throw new Unauthorized('Token is invalid or user does not exist'); 
    }

    // update user data
    user.otp_enabled = true;
    user.otp_verified = true;
    
    // generate recovery codes
    const codeLength = 8;
    const recoveryCodesSize = 10;

    const recoveryCodes = this.generateRandomStringArray(codeLength, recoveryCodesSize);
    // hash recovery codes
    const hashedRecoveryCodes = await this.hashRecoveryCodes(recoveryCodes);
    // save hasded codes to user doc
    user.recoveryCodes = hashedRecoveryCodes;

    const updatedUser = await user.save();

    return {
      otp_verified: true,
      user: {
        id: updatedUser._id,
        name: updatedUser.name,
        email: updatedUser.email,
        otp_enabled: updatedUser.otp_enabled
      },
      recoveryCodes: recoveryCodes
    }
  }

  /**
   * validate otp codes generated by user's authenticator app
   */
  public async validateOTP(userId: string, token: string) {
    const user = await this.UserService.findById(userId);
    const secret = user.otp_base32;

    let totp = this.generateTOTP(secret, user.email);

    let delta = totp.validate({ token, window: 1 });

    if(delta === null) {
      throw new Unauthorized('Token is invalid or user does not exist');
    }

    return { otp_valid: true };
  }

  /**
   * disabelOTP
   */
  public async disabelOTP(userId: string, token: string) {
    const user = await this.UserService.findById(userId);
    const secret = user.otp_base32;

    let totp = this.generateTOTP(secret, user.email);

    let delta = totp.validate({ token, window: 1 });

    if(delta === null) {
      throw new Unauthorized('Token is invalid or user does not exist');
    }

    user.otp_enabled = false;
    user.otp_verified = false;
    user.otp_base32 = '';
    user.otp_auth_url = '';

    const updatedUser = await user.save();

    return {
      otp_disabled: true,
      user: {
        id: updatedUser._id,
        name: updatedUser.name,
        email: updatedUser.email,
        otp_enabled: updatedUser.otp_enabled
      }
    }
  }

  /**
   * otpData
   */
  public async otpData(userId: string) {
    const user = await this.UserService.findById(userId);
    const enabled = user.otp_auth_url;
    if(!enabled) throw new Unauthorized('User otp not enabled');
    
    // based on users otp status return certain data
    return {
      otp_auth_url: user.otp_auth_url,
      otp_base32: user.otp_base32
    }
  }

  /**
   * send data as qrcode
   * a qrcode fileStream is created and piped to the response stream
   * e.g for a PaymentService
   */
  public async responseWithQRCode(data: string, res: Response) {
    const qrStream = new PassThrough();
    await QRCOde.toFileStream(qrStream, data, {
      width: 200
    });

    qrStream.pipe(res);
  }

  /**
   * generateRandomString
   */
  public generateRandomString(length: number) {
    const characters = process.env.SECRET_CHARACTERS!;
    // number of characters available for selection
    const characterCount = characters.length;

    // will return an ArrayBuffer
    const bytes = randomBytes(length);
    let randomString = '';

    for (let i = 0; i < length; i++) {
      // value of the byte at index 'i' of buffer => bytes[i]
      // randomIndex should be within the range of avalable characters
      const randomIndex = bytes[i] % characterCount;

      // select corresponding character at randomindex and append to 'randomString'
      randomString += characters.charAt(randomIndex);
    }

    return randomString;
  }

  /**
   * generateRandomStringArray
   * generate recovery codes of size `count` for 2fa enabled accounts,
   * each code has a `length`
   */
  public generateRandomStringArray(length: number, count: number) {
    const randomStrings = [];

    for (let i = 0; i < count; i++) {
      const randomString = this.generateRandomString(length);
      randomStrings.push(randomString);
    }
    // random string uniqueness, cache db?, do-while(generatedStrings.has(generatedString) && generatedSize < count)...

    return randomStrings;
  }

  /**
   * hashStrings
   * hash recovery codes of user
   */
  public async hashRecoveryCodes(recoveryCodes: string[]) {
    // await the result of the iterable code
    const hashedCodes = await Promise.all(
      // iterate over the array
      recoveryCodes.map( async (code) => {
        // hash each code and return an object with a 'used' property
        const hasedCode = await hash(code, 7);
        return {
          hash: hasedCode,
          used: false
        }
      })
    );
    return hashedCodes;
  }

  /**
   * validateRecoveryCode
   * if no match is found will return `undefined`
   */
  public async validateRecoveryCode(userId: string, recoverCode: string) {
    const user = await this.UserService.findById(userId);
    const recoveryCodes = user.recoveryCodes;

    for (const code of recoveryCodes) {
      const isMatch = await compare(recoverCode, code.hash);

      // using `if(!isMatch) or if-else` will exit the loop        
      // fast if a match is not found after first iteration
      if (isMatch) {
        if (code.used) {
          throw new Forbidden('Code already used');
        } else {
          code.used = true;
          await user.save();

          return {validCode: true, message: 'valid code'};
        }
      }
    }
  }

  /**
   * validCode
   * handle a `undefined` cases from `validateRecoveryCode` method
   */
  public async validCode(userId: string, recoveryCode: string) {
    const result = await this.validateRecoveryCode(userId, recoveryCode);
    if (!result) {
      throw new Forbidden('Code does not exist');
    }
    return result;
  }

  /**
   * verifyEmail
   */
  public async verifyEmail(email: string) {
    const user = await this.UserService.findbyEmail(email);

    if (!user) {
      throw new NotFound('user not found');
    }

    // call a method to generate a secret_token for a user
    // save generated token to user's db
    // encode a jwt for the secret and set an expiry date
    // generate the auth 'url' containing the generated jwt and user._id and the api endpoint for processing
    // user._id (a fall back to override saved secret_token if user dpesn't verify during the given duration)

    // send email => user.email, user.name, url email service
    // return {verification email sent}
  }

  // validateEmail method 
  // param token, id
  // verify token
  // handle error, if jwt expires(find a way to check for time based expiration)
  // use user._id form req.param to remove saved secret_token and update user
  // if valid set user.verified to true and delete generated secret_token
  // return {verification email}

  // resetPassword
  // mongooseSchema pre middleware for hashing password, if it will work for => user.pass = newpass; user.save();

  // resetOtp method
  // if user has no access to auth app or recovery codes,
  // send an email with a otp to validate their account ownership
  // if code is valid, can disable their otp_status
  // if user enables otp again, a new otp_auth_url and recovery codes will be given
}

export default AuthService;
